# План улучшения DOCX-парсера

## Цель

Обеспечить полное сравнение Word-документов во всех форматах вывода: DOCX с Track Changes **и** HTML/Excel-отчёты. Оба формата должны видеть изменения в любом месте документа — в теле, таблицах, колонтитулах и текстовых блоках.

---

## Два пути сравнения DOCX

В программе существуют **два независимых пути** для работы с Word-файлами:

### Путь 1 — DOCX с Track Changes (`reporters/docx_reporter.py`)
Использует **Microsoft Word напрямую** через COM-автоматизацию (`word.Application.CompareDocuments`). Word сам выполняет сравнение и генерирует документ с правками. Этот путь **уже работает полностью** — таблицы, текстбоксы, колонтитулы, сноски, поля, комментарии (`CompareTextboxes=True`, `CompareHeaders=True` и т.д.). Трогать не нужно.

### Путь 2 — HTML/Excel-отчёты (`parsers/docx_parser.py` → diff engine → репортеры)
Использует python-docx для парсинга файлов в сегменты, затем движок сравнения, затем генерацию HTML/Excel. **Этот путь слепой** — парсер видит только параграфы тела документа. Таблицы, текстбоксы, колонтитулы полностью пропускаются. Именно здесь и нужна работа.

---

## Текущее состояние парсера (`parsers/docx_parser.py`)

Парсер использует `document.paragraphs` — стандартный API python-docx, который возвращает **только параграфы основного тела** документа. Всё остальное игнорируется.

| Тип контента         | DOCX Track Changes | HTML/Excel сейчас | HTML/Excel после улучшения |
|----------------------|--------------------|-------------------|---------------------------|
| Параграфы тела       | ✅                  | ✅                 | ✅                          |
| Таблицы              | ✅                  | ❌                 | ✅                          |
| Верхний колонтитул   | ✅                  | ❌                 | ✅                          |
| Нижний колонтитул    | ✅                  | ❌                 | ✅                          |
| Текстовые блоки      | ✅                  | ❌                 | ✅ (приоритет)              |
| Сноски               | ✅                  | ❌                 | ✅                          |
| Концевые примечания  | ✅                  | ❌                 | ✅                          |

---

## Ключевое архитектурное решение

Word-документ внутри — это XML. Весь текст хранится в тегах `<w:t>`, сгруппированных в `<w:p>` (параграф). Параграфы присутствуют **во всех типах контейнеров**: в теле, в ячейках таблиц, в колонтитулах, в текстовых блоках.

**Стратегия:** вместо разрозненных вызовов API (`document.paragraphs`, `document.tables`) — единый рекурсивный обход XML-дерева, который собирает `<w:p>` из любого контейнера в правильном порядке.

---

## Этапы

---

### Этап 1 — Тело документа + таблицы

**Проблема текущего кода:**
`document.paragraphs` и `document.tables` — отдельные списки без информации о взаимном порядке. Если в документе: параграф → таблица → параграф, парсер выдаёт: все параграфы → все таблицы. Порядок нарушен.

**Решение:**
Итерировать `document.element.body` напрямую — дочерние XML-элементы идут в том же порядке, что на странице:
- `<w:p>` → параграф → добавить сегмент
- `<w:tbl>` → таблица → рекурсивно обойти `строка → ячейка → параграф`

**Результат:** правильный порядок сегментов, все ячейки таблиц попадают в сравнение.

**ID сегментов:** сейчас `para_{N}` — нужно сделать уникальными с учётом вложенности, например `body_p1`, `table1_r2_c3_p1`, чтобы избежать конфликтов при матчинге.

---

### Этап 2 — Колонтитулы

**Доступ:** через `document.sections` — у каждой секции есть `.header` и `.footer`, каждый содержит свои `<w:p>` и `<w:tbl>`.

**Решение:** после обхода тела — пройтись по всем секциям, применить тот же рекурсивный метод к хедеру и футеру каждой секции.

**Особенность:** если в документе несколько секций с разными колонтитулами — обработать каждый. Дублирующиеся (linked to previous) пропустить.

---

### Этап 3 — Текстовые блоки (приоритет)

**Проблема:** python-docx не предоставляет никакого API для текстовых блоков. Они хранятся в XML как `<w:txbxContent>` внутри `<w:drawing>` или `<mc:AlternateContent>`.

**Решение:** отдельный XML-поиск по всему документу через XPath или `iter()`:
1. Найти все элементы `<w:txbxContent>` в `document.element`
2. Внутри каждого рекурсивно собрать параграфы тем же методом
3. Добавить сегменты в конец основного списка

Это единственное место, где нужен прямой XML-хак — для всего остального достаточно python-docx API.

---

### Этап 4 — Сноски и концевые примечания

**Доступ:** хранятся в отдельных XML-файлах внутри `.docx` архива:
- `word/footnotes.xml`
- `word/endnotes.xml`

Доступ через `document.part.footnotes` (низкоуровневый API python-docx).

**Решение:** открыть XML-часть, найти все `<w:footnote>` / `<w:endnote>` (кроме служебных с id=-1 и id=0), внутри каждого собрать параграфы.

---

## Что НЕ меняется

| Компонент                        | Изменения  | Причина                                      |
|----------------------------------|------------|----------------------------------------------|
| `core/models.py`                 | Не трогаем | Модели достаточны                            |
| `core/diff_engine.py`            | Не трогаем | Fuzzy matching справится с новыми сегментами |
| `core/orchestrator.py`           | Не трогаем |                                              |
| `reporters/html_reporter.py`     | Не трогаем | Получит больше сегментов автоматически       |
| `reporters/excel_reporter.py`    | Не трогаем | То же самое                                  |
| `reporters/docx_reporter.py`     | Не трогаем | Уже работает полностью через Word COM        |
| Логика матчинга                  | Не трогаем |                                              |

Единственный изменяемый файл: **`parsers/docx_parser.py`**.

---

## Потенциальные риски

**1. Рост числа сегментов**
После расширения парсера документ с таблицами и текстбоксами будет давать значительно больше сегментов. Это ожидаемо и корректно — именно это и нужно.

**2. Взрыв DELETED при структурных различиях**
Если файл A содержит таблицу, а файл B — нет, все сегменты таблицы уйдут в DELETED. Это правильное поведение.

**3. Конфликты ID**
Текущие ID вида `para_{N}` станут неуникальными при добавлении нескольких контейнеров. Решается иерархической схемой ID (см. Этап 1).

**4. linked-to-previous колонтитулы**
В многосекционных документах колонтитулы могут быть "унаследованы" от предыдущей секции. Нужно проверять флаг `is_linked_to_previous` и не дублировать сегменты.

---

## Порядок реализации

```
Этап 1: тело + таблицы   ← начать здесь
    ↓
Этап 2: колонтитулы
    ↓
Этап 3: текстовые блоки  ← приоритет пользователя
    ↓
Этап 4: сноски
```

Каждый этап независим и полезен сам по себе. После каждого этапа парсер работоспособен.

---

## Файлы

| Файл | Роль |
|------|------|
| `parsers/docx_parser.py` | Единственный изменяемый файл |
| `parsers/base.py` | Интерфейс — не меняем |
| `core/models.py` | Модели — не меняем |
